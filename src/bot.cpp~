void bot_job()
{
	Arr[N].radius=0.05;
	if(turn==0)
	Arr[N].y=-d;
	else if(turn==1)
	Arr[N].x=-d;
	else if(turn==2)
	Arr[N].y=d;
	else
	Arr[N].x=d;
	int flag1=0;
	srand ( time(NULL) );
	
	for(int i=0;i<N;i++)
	{
		int flag3=0;
		if(M==2 && Arr[0].radius!=-1 && i!=0)
		continue;
		if(Arr[i].radius==-1)
		continue;
		for(int l=0;l<=3;l++)
		{
			float x1,y1;
			if(turn==0)
			{
				x1=0.89;
				y1=0.89;
			}
			else if(turn==1)
			{
				x1=0.89;
				y1=-0.89;
			}
			else if(turn==2)
			{
				x1=-0.89;
				y1=-0.89;
			}
			else
			{
				x1=-0.89;
				y1=0.89;
			}
			bool flag2;
			int flag=0;
			if(turn==0)
			{
				if(l<2 && Arr[i].y<-0.7)
				continue;
				if(l>=2 && Arr[i].y>-0.7)
				continue;
			}
			else if(turn==1)
			{
				if(l<2 && Arr[i].x<-0.7)
				continue;
				if(l>=2 && Arr[i].x>-0.7)
				continue;
			}
			else if(turn==2)
			{
				if(l<2 && Arr[i].y>0.7)
				continue;
				if(l>=2 && Arr[i].y<0.7)
				continue;
			}
			else
			{
				if(l<2 && Arr[i].x>0.7)
				continue;
				if(l>=2 && Arr[i].x<0.7)
				continue;
			}
			if(l==1)
			{
				if(turn==0 || turn==2)
				x1=-x1;
				else
				y1=-y1;
			}
			else if(l==2)
			{
				if(turn==0 || turn==2)
				y1=-y1;
				else
				x1=-x1;
			}
			else if(l==3)
			{
				x1=-x1;
				y1=-y1;
			}
			float x2=Arr[i].x;
			float y2=Arr[i].y;
			float m=(y2-y1)/(x2-x1);
			float a=m;
			float b=-1;
			float c=-m*x1+y1;
			float y3;
			float x3;
			if(turn==0)
				y3=-d;
			if(turn==1)
				x3=-d;
			if(turn==2)
				y3=d;
			if(turn==3)
				x3=d;
			
			if(turn==0 || turn==2)
				x3=x2+(y3-y2)/m;
			else
				y3=y2+m*(x3-x2);
			if(turn==0 || turn==2)
				if(x3<-d+0.1 || x3>d-0.1)
					continue;
			if(turn==1 || turn==3)
				if(y3<-d+0.1 || y3>d-0.1)
					continue;
			for(int j=0;j<N;j++)
			{
				if(i==j)
				continue;
				if(Arr[j].radius==-1)
				continue;
				if(turn==0)
				{
					if(l<2)
					flag2=Arr[i].y>-d;
					else
					flag2=Arr[i].y<-d;
				}
				else if(turn==1)
				{
					if(l<2)
					flag2=Arr[i].x>-d;
					else
					flag2=Arr[i].x<-d;
				}
				else if(turn==2)
				{
					if(l<2)
					flag2=Arr[i].y<d;
					else
					flag2=Arr[i].y>d;
				}
				else
				{
					if(l<2)
					flag2=Arr[i].x<d;
					else
					flag2=Arr[i].x>d;
				}
				float dis1=sqrt((x3-Arr[j].x)*(x3-Arr[j].x)+(y3-Arr[j].y)*(y3-Arr[j].y));
				float dis2=Arr[N].radius+Arr[j].radius;
				if(dis1<=dis2)
				{
					flag=1;
					break;
				}
				if(flag2)
				{
					double dis3=abs(a*Arr[j].x+b*Arr[j].y+c)/(sqrt(a*a+b*b));
					double dis4=2*Arr[i].radius;
					bool test1;
					if(turn==0)
					test1=Arr[j].x>x2;
					else if(turn==1)
					test1=Arr[j].y<y2;
					else if(turn==2)
					test1=Arr[j].x<x2;
					else
					test1=Arr[j].y>y2;
					if(test1)
					{
						if(dis3<dis4)
						{
							flag=1;
							break;	
						}
					}
					else
					{
						if(dis3<dis2)
						{
							flag=1;
							break;
						}
					}
				}
			}
			if(flag==0)
			{
				Arr[N].x=x3;
				Arr[N].y=y3;
				float d1=sqrt((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3));
				float c=(x1-x3)/d1;
				float s=(y1-y3)/d1;
				int flag4=0;
				for(int p=0;p<N;p++)
				{
					if(Arr[p].radius==-1)
					continue;
					float dd=sqrt((Arr[N].x-Arr[p].x)*(Arr[N].x-Arr[p].x)+(Arr[N].y-Arr[p].y)*(Arr[N].y-Arr[p].y));
					if(dd<Arr[N].radius+Arr[p].radius)
					{	
						flag4=1;
						break;
					}
				}
				if(flag4==1)
				continue;
				if(l<2)
				{
					if(difficulty<2)
					{
						double theta=acos(c);
						double theta1=asin(s);
						double random=1.0*(rand()%10000)/10000;
						if(difficulty==1)
						{
							theta=theta-2.5*M_PI/180+5*M_PI*random/180;
							theta1=theta1-2.5*M_PI/180+5*M_PI*random/180;
						}
						else
						{
							theta=theta-5*M_PI/180+10*M_PI*random/180;
							theta1=theta1-5*M_PI/180+10*M_PI*random/180;
						}
						c=cos(theta);
						s=sin(theta1);
					}
					Arr[N].vx=5*aimlen*c;
					Arr[N].vy=5*aimlen*s;
				}
				else
				{
					if(difficulty<2)
					{
						double theta=acos(c);
						double theta1=asin(s);
						double random=1.0*(rand()%10000)/10000;
						if(difficulty==1)
						{
							theta=theta-2.5*M_PI/180+5*M_PI*random/180;
							theta1=theta1-2.5*M_PI/180+5*M_PI*random/180;
						}
						else
						{
							theta=theta-5*M_PI/180+10*M_PI*random/180;
							theta1=theta1-5*M_PI/180+10*M_PI*random/180;
						}
						c=cos(theta);
						s=sin(theta1);
					}
					Arr[N].vx=6.1*aimlen_back*c;
					Arr[N].vy=6.1*aimlen_back*s;
				}					
				flag1=1;
				flag3=1;
				break;
			}
		
		}
		if(flag3==1)
		break;	
	}
	if(flag1==0)
	{
		float x4;
		float y4;
		if(turn==0)
			y4=-d;
		else if(turn==1)
			x4=-d;
		else if(turn==2)
			y4=d;
		else
			x4=d;
		int k1=-1;
		int k2=-1;
		int k3=-1;
		float min_angle=1000000;
		for(int j=0;j<=1;j++)
		{
			if(turn==0)
			{
				if(j==0)
					x4=-d+0.1;
				else
					x4=d-0.1;
			}
			else if(turn==1)
			{
				if(j==0)
					y4=d-0.1;
				else
					y4=-d+0.1;
			}
			else if(turn==2)
			{
				if(j==0)
					x4=d-0.1;
				else
					x4=-d+0.1;
			}
			else
			{
				if(j==0)
					y4=-d+0.1;
				else
					y4=d-0.1;
			}
			for(int i=0;i<N;i++)
			{
				if(M==2 && Arr[0].radius!=-1 && i!=0)
				continue;
				if(Arr[i].radius==-1)
				continue;
				for(int l=0;l<=3;l++)
				{
					float x1,y1;
					if(turn==0)
					{
						x1=0.89;
						y1=0.89;
					}
					else if(turn==1)
					{
						x1=0.89;
						y1=-0.89;
					}
					else if(turn==2)
					{
						x1=-0.89;
						y1=-0.89;
					}
					else
					{
						x1=-0.89;
						y1=0.89;
					}
					if(l==1)
					{
						if(turn==0 || turn==2)
						x1=-x1;
						else
						y1=-y1;
					}
					if(l==2)
					{
						if(turn==0 || turn==2)
						y1=-y1;
						else
						x1=-x1;
					}
					if(l==3)
					{
						x1=-x1;
						y1=-y1;
					}
					float x2=Arr[i].x;
					float y2=Arr[i].y;
					float D1=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
					float D2=Arr[i].radius+Arr[N].radius;
					float x3=((D1+D2)*x2-D2*x1)/D1;
					float y3=((D1+D2)*y2-D2*y1)/D1;
					float dis1=sqrt((x3-x4)*(x3-x4)+(y3-y4)*(y3-y4));
					float dis2=sqrt((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4));
					float dis3=D1+D2;
					if(dis2*dis2<=(dis1*dis1+dis3*dis3))
						continue;
					float m1=(y1-y2)/(x1-x2);
					float m2=(y3-y4)/(x3-x4);
					float m3=abs((m1-m2)/(1+m1*m2));
					float a1=m1;
					float b1=-1;
					float c1=-m1*x1+y1;
					float a2=m2;
					float b2=-1;
					float c2=-m2*x3+y3;
					int flag2=0;
					bool test1,test2;
					for(int m=0;m<N;m++)
					{
						if(m==i)
						continue;
						if(Arr[m].radius==-1)
						continue;
						if(turn==0)
						test1=Arr[m].y>y2;
						else if(turn==1)
						test1=Arr[m].x>x2;
						else if(turn==2)
						test1=Arr[m].y<y2;
						else
						test1=Arr[m].x<x2;
						if(l==2 || l==3)
						{
							test1=!(test1);
						}
						double dis4=abs((a1*(Arr[m].x)+b1*(Arr[m].y)+c1)/sqrt(a1*a1+b1*b1));
						double dis5=abs((a2*(Arr[m].x)+b2*(Arr[m].y)+c2)/sqrt(a2*a2+b2*b2));
						if(test1)
						{
							if(dis4<2*Arr[i].radius)
							{
								flag2=1;
								break;
							}
						}
						else
						{
							double dis6=sqrt((x4-Arr[m].x)*(x4-Arr[m].x)+(y4-Arr[m].y)*(y4-Arr[m].y));
							if(turn==0)
							test2=Arr[m].y>=y4;
							else if(turn==1)
							test2=Arr[m].x>=x4;
							else if(turn==2)
							test2=Arr[m].y<=y4;
							else
							test2=Arr[m].x<=x4;
							if(l==2 || l==3)
							{
								test2=!(test2);
							}
							if(dis6<Arr[N].radius+Arr[m].radius)
							{
								flag2=1;
								break;
							}
							if(test2 && dis5<Arr[i].radius+Arr[N].radius)
							{
								flag2=1;
								break;
							}
						}
					}
					if(flag2==1)
					continue;
					if(m3<min_angle)
					{
						min_angle=m3;
						k1=i;
						k2=l;
						k3=j;
					}
				}
			}
		}
		if(k1!=-1)
		{
			float x2=Arr[k1].x;
			float y2=Arr[k1].y;
			float x1;
			float y1;
			float x4;
			float y4;
			if(turn==0)
				y4=-d;
			else if(turn==1)
				x4=-d;
			else if(turn==2)
				y4=d;
			else
				x4=d;
			if(turn==0)
			{
				x1=0.89;
				y1=0.89;
			}
			else if(turn==1)
			{
				x1=0.89;
				y1=-0.89;
			}
			else if(turn==2)
			{
				x1=-0.89;
				y1=-0.89;
			}
			else
			{
				x1=-0.89;
				y1=0.89;
			}
			if(k2==1)
			{
				if(turn==0 || turn==2)
				x1=-x1;
				else
				y1=-y1;
			}
			else if(k2==2)
			{
				if(turn==0 || turn==2)
				y1=-y1;
				else
				x1=-x1;
			}
			else if(k2==3)
			{
				x1=-x1;
				y1=-y1;
			}
			if(k3==0)
			{
				if(turn==0)
				x4=-d+0.1;
				else if(turn==1)
				y4=d-0.1;
				else if(turn==2)
				x4=d-0.1;
				else
				y4=-d+0.1;
			}
			else
			{
				if(turn==0)
				x4=d-0.1;
				else if(turn==1)
				y4=-d+0.1;
				else if(turn==2)
				x4=-d+0.1;
				else
				y4=d-0.1;
			}
			float D1=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
			float D2=Arr[k1].radius+Arr[N].radius;
			float x3=((D1+D2)*x2-D2*x1)/D1;
			float y3=((D1+D2)*y2-D2*y1)/D1;
			Arr[N].x=x4;
			Arr[N].y=y4;
			float dis=sqrt((x4-x3)*(x4-x3)+(y4-y3)*(y4-y3));
			float c=(x3-x4)/dis;
			float s=(y3-y4)/dis;
			if(k2<2)
			{
				if(difficulty<2)
				{
					double theta=acos(c);
					double theta1=asin(s);
					double random=1.0*(rand()%10000)/10000;
					if(difficulty==1)
					{
						theta=theta-2.5*M_PI/180+5*M_PI*random/180;
						theta1=theta1-2.5*M_PI/180+5*M_PI*random/180;
					}
					else
					{
						theta=theta-5*M_PI/180+10*M_PI*random/180;
						theta1=theta1-5*M_PI/180+10*M_PI*random/180;
					}
					c=cos(theta);
					s=sin(theta1);
				}
				Arr[N].vx=6*aimlen*c;
				Arr[N].vy=6*aimlen*s;
			}
			else
			{
				if(difficulty<2)
				{
					double theta=acos(c);
					double theta1=asin(s);
					double random=1.0*(rand()%10000)/10000;
					if(difficulty==1)
					{
						theta=theta-2.5*M_PI/180+5*M_PI*random/180;
						theta1=theta1-2.5*M_PI/180+5*M_PI*random/180;
					}
					else
					{
						theta=theta-5*M_PI/180+10*M_PI*random/180;
						theta1=theta1-5*M_PI/180+10*M_PI*random/180;
					}
					c=cos(theta);
					s=sin(theta1);
				}
				Arr[N].vx=8*aimlen_back*c;
				Arr[N].vy=8*aimlen_back*s;
			}
		}
	}
	if(Arr[N].vx==0 && Arr[N].vy==0)
	{
		if(turn==0)
		{
			Arr[N].x=0;
			Arr[N].y=-d;
		}
		else if(turn==1)
		{
			Arr[N].y=0;
			Arr[N].x=-d;
		}
		else if(turn==2)
		{
			Arr[N].x=0;
			Arr[N].y=d;
		}
		else
		{
			Arr[N].y=0;
			Arr[N].x=d;
		}
		int flag_tmp=0;
		for(int i=0;i<N;i++)
		{
			if(Arr[i].radius!=-1)
			{
				float c=(Arr[i].x-Arr[N].x)/sqrt((Arr[i].x-Arr[N].x)*(Arr[i].x-Arr[N].x)+(Arr[i].y-Arr[N].y)*(Arr[i].y-Arr[N].y));
				float s=(Arr[i].y-Arr[N].y)/sqrt((Arr[i].x-Arr[N].x)*(Arr[i].x-Arr[N].x)+(Arr[i].y-Arr[N].y)*(Arr[i].y-Arr[N].y));
				Arr[N].vx=6*aimlen*c;
				Arr[N].vy=6*aimlen*s;
				flag_tmp=1;
				break;
			}
		}
		if(flag_tmp==0)
		{
			Arr[N].vy=4*aimlen/sqrt(2);
			Arr[N].vx=4*aimlen/sqrt(2);
		}
	}
	if(network==1)
	{
		int n1=write(sockfd,&Arr[N],sizeof(Arr[N]));
		if(svr==1)
		{
			if(players==4)
			{
				n1=write(sockfd1,&Arr[N],sizeof(Arr[N]));
				n1=write(sockfd2,&Arr[N],sizeof(Arr[N]));
			}
		}
	}
	clickl=2;
}
